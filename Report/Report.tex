% Created 2020-09-30 Wed 23:32
% Intended LaTeX compiler: xelatex
\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\input{header.tex}
\setcounter{secnumdepth}{2}
\author{Abhaas Goyal (u7145384)}
\date{\today}
\title{Assignment 1 COMP2310}
\hypersetup{
 pdfauthor={Abhaas Goyal (u7145384)},
 pdftitle={Assignment 1 COMP2310},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.1.9)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setlength\parindent{0pt}

\section{Introduction}
\label{sec:orga4f60e0}
The following report is an analysis of a simulation for Distributed Message Passing given for Assignment 1 of COMP2310. This report starts with Stage B implementation however the only major difference between the implementations of stage A and stage B was the message passing algorithm. While in Stage A the vehicles referred to a common variable keeping \texttt{Globe'First} (which was itself being continuously overwritten by every vehicle - This meant that the implementation would work stably only when a single globe is present), stage B moved onto a more sophisticated method of keeping a record, sharing the closest globe it could find and making decisions on the information received in the process.
\section{Stage B and C}
\label{sec:orgb2b0ca6}
\subsection{Motion Structure}
\label{sec:org432011f}
By watching several videos given in Assignment Page[1], I got the notion that the I should first start with the aspect of controlling the motion of vehicles. Because if that were to be controlled, then the vehicles could decide to move to the globe in a coordinated manner and message passing would become highly efficient. From being inspired by Charging groups [1] and the fact that the position of the globe is dependent on it's centre of mass, I decided to make a similar Model of circular motion around the Energy Globe. Initially, I chose 2 axis of revolution but from testing for large number of vehicles (around 200\textasciitilde{}) and not being supported, I decided to make them four. By using principles of linear algebra, I decided to assign a fixed axis to a vehicle. Given radius \(r\), Angle in XY plane \(\theta\) and angle in XZ plane \(\phi\) the motion [3] given by the formula :

\begin{align*}
  \begin{bmatrix}
cos (\phi) & -sin (\phi) & 0 \\
sin (\phi) & cos (\phi) & 0 \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
x \\ y \\ z
\end{bmatrix}
 &=
\begin{bmatrix}
x cos (\phi)  - y sin (\phi)  \\
x sin (\phi) + y cos (\phi)  \\
z
\end{bmatrix} \\
\text{where }
\begin{bmatrix}
x \\ y \\ z
\end{bmatrix}
 &=
\begin{bmatrix}
r sin (\theta)   \\
0  \\
r cos (\theta)
\end{bmatrix}
+
\begin{bmatrix}
x'   \\
y'  \\
z'
\end {bmatrix}
\end{align*}
where \((x',y',z')\) are coordinates of the globes.

Changing \(\theta\) clockwise in every clock step meant that the vehicle has someplace to go with respect to the vehicle. This seemed to work great until I reached around 250 globes. In this case the vehicles seemed to be very crowded and the design did not seem to be feasible in a large scale. After some thinking I realized that while rotating the space in between the vehicle and the globes was being wasted. So I made the radius of rotation with respect to the current charge present in the globe (again inspired from Charging Groups). So now the radius position would be calculated by:
\begin{align*}
r &= c * \text{Vehicle charge}
\end{align*}
\begin{itemize}
\item The value of the constant \(c\) was taken on the basis of that it shouldn't be too high to be very far away from the globes and neither should it create a blocking operation for large number of vehicles.
\item The axis' for the vehicles were decided on the \texttt{Vehicle\_Id mod 4}. While still not a perfect metric, in real life if we assume a random distribution, equal number of vehicles would be there in different axis
\item However, it is also to be taken into consideration that the motion of vehicles being created from the model supports having different vehicles in different axis since the center of mass roughly stays the same.
\item Also while moving in the \texttt{Throttle} of the Vehicle is set to low to conserve it's energy.
\item Now the vehicle seemed to go in a continuous spiral motion.
\end{itemize}

A diagram representing the above concepts is given below:-
\begin{figure}[!htb]
\minipage{0.45\textwidth}
  \includegraphics[width=\linewidth, trim={3cm 12cm 3cm 2cm}, clip]{Model.pdf}
  \caption{Model for Vehicle Motion}\label{fig:Model}
\endminipage\hfill
\minipage{0.45\textwidth}%
  \includegraphics[width=\linewidth,trim={3cm 12cm 3cm 2cm}, clip]{Spiral.pdf}
  \caption{Proposed Motion of Individual Vehicle}\label{fig:Spiral}
\endminipage
\end{figure}
\subsection{Reading of Energy Globes}
\label{sec:org6fd4928}
The reading of energy globes was done by the implementation given on the discussion forums [2]. In addition to the implementation, the vehicles will store the closest globe in their \texttt{Local\_Record} while at the same time sending the location of multiple globes that it could find (that meant it could potentially work with multiple globes if message passing was done properly).
\subsection{Message Passing}
\label{sec:orgaaca2cf}
Now come the three pillars of actual message passing algorithm

\begin{itemize}
\item The central keypoint to be taken is the \texttt{Time\_Stamp} of the messages. Whenever a vehicle receives a message, the globe position would only be updated on the basis of the latest timestamp. This ensures that the vehicles stay up to date as globe as possible
\item One difficult point was how could the messages be wholly distributed. By looking at some videos of Swarm Intelligence and after some thinking, the answer lied in filtering and propagating the message everytime further on receiving one. This ensures that the sending and receiving will happen everytime and the operations will always happen in a circular manner.
\item The third pillar stood in the fact of when exactly to receive the messages. If the Vehicle's battery is very low, it waits for any latest message being received (a blocking operation) of the globe's position. If it's higher than that, it will move peacefully in it's orbit or update the globe's position in it's database
\end{itemize}

The structure of motion of vehicles helps in the fact that the vehicles stay close to each other and the vehicle would always certainly receive a message if it has low battery. Graceful degredation method was provided in case the vehicle couldn't find a globe to go.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth, trim={0.0cm 13cm 0cm 0cm}, clip]{Stage_A_Algo.pdf}
    \caption{Central Algorithm used for Stage B}
    \end{figure}

\begin{itemize}
\item On test runs, the first iteration in which all vehicles seemed to move to the globe at once made it seem like the vehicles were rotating along different points of the axis Figure: \ref{fig:Unstable_B} . However, after a certain period of time Figure: \ref{fig:Stable_B} was obtained.

\item From the data collected with respect to number of ships, the most efficient number of ships were found to be around 250. And the test runs seemed to indicate that after 1-2 iterations of all the vehicles' recharging cycle, no vehicle seemed to die for sustained periods of time. Upon further analysis of the motion of vehicles, it was found that on the first run, all the vehicles seemed to charge at the globe at roughly the same time, even though their motion was stable. Because of so many vehicles blocked to go at the same destination, if the number of vehicles are very high, the vehicles will die before reaching the globe for the first time. Also since the vehicles recharge one by one, their charges will go off at slighly different time steps, so in other iterations the tasks would not be blocking to the same destination.
\begin{figure}[!htb]
\minipage{0.49\textwidth}
  \includegraphics[width=\linewidth]{Stage_B_Initial}
  \caption{Unstable Initial Configuration}\label{fig:Unstable_B}
\endminipage\hfill
\minipage{0.49\textwidth}%
  \includegraphics[width=\linewidth]{Stage_B_Final}
  \caption{Stable Timely Configuration}\label{fig:Stable_B}
\endminipage
\end{figure}
\end{itemize}

Due to the simplicity of the algorithm and Vehicles easily changing spiral orbits without any problem, it produced even better results in Stage C and the proble of blocking operations seemed much less because of distribution among the energy globes. Although the vehicles in Stage B are stable till 250, the death rate seems to increase by a high margin after that. But in random globes configuration a lot more vehicles are supported. However, Stage C configuration can't guarantee staying alive at any number  (although the vehicles would eventually die with a higher probability when low number of vehicles are there). Some of the observed reasons were -
\begin{enumerate}
\item The vehicles in their low battery were going to refill and as soon as they almost reached the globe the globe went missing and the vehicle couldn't find the globe
\item When a particular globe died and it was far away from the other globes the vehicles had difficulty finding another globe with respect to their movement.
\item Even if they found the globe in the above case, it would still make it difficult for all of them to get accomodated to the new structure and recharge.
\end{enumerate}

\section{Stage D}
\label{sec:org6c32d5e}
\subsection{Motivation}
\label{sec:org32c4b10}
\begin{itemize}
\item My approach was to build a common lookup table for all the vehicles for storing \texttt{Vehicle\_Id} for all other Vehicles in a sorted order and have a consensus on which table to use. With respect to that, I built a generic data structure with operations from scratch (properties inspired by [4]) from which one can store and Receive the sorted list. The algorithm is given as a flowchart in the next page.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth, trim={0.0cm 10cm 0cm 0cm}, clip]{Stage_D_Algo.pdf}
    \caption{Central Algorithm used for Stage D}
    \end{figure}
\item I wanted to have a clean design for stage D so I built it on top of stage C and the user can chose whether to implement Stage B/C/D just by changing 2-3 lines of code.
\end{itemize}
The difference between my implementation of Stage B and Stage D implementations with respect to timestamps is that in Stage D, I am expecting the Vehicle which constructs the \texttt{Local\_List} (Local Lookup Table) first will have the priority over all other completed lists. This is oppsite from Stage B implementation where the last timestamp held precedence over earlier timestamps. Another key difference is in the records being sent. I have made two types of records being sent (\texttt{Type\_X} is for \texttt{Globe\_Pos} Messages and \texttt{Type\_Y} is for building the common lookup table. This approach sacrifices the continuous sending of \texttt{Type\_X} messages so the globe positions would not be updated as frequently (in the start of vehicles reaching the next coordinate). However, this behaviour is eliminated after sometime since the messages are sent safely before the vehicle reaches it's destination. \\

\begin{itemize}
\item Designing the data structure and it's operations was a very difficult task to do since a high amount of accuracy was needed in all the cases. For that while building any function of \texttt{concrete\_order}, I tested it using a variety of inputs. In some cases, I was unable to find any errors in testing however when I used the data structure in multiple tasks (especially \texttt{Write\_List} and \texttt{Max\_Union}), manipulation of \texttt{Number\_Of\_Tasks} had to be controlled properly. \\

\item After constructing the lookup table there is a \texttt{Consensus\_Time\_Interval} which believes that the lookup tables have been constructed at that point. If the vehicle is not in the list kill it else there is no need. This even ensures that if the \texttt{Target\_No\_Of\_Elements} is mistakenly set greater than the initial amount of vehicles, no vehicles will die (Robustness).
\end{itemize}
\subsection{Construction and Result Analysis}
\label{sec:org40828f1}
\begin{itemize}
\item Since this is not a request/response architecture, there is not much problem in having unresponsive messages from the receiver's side (since if it just stops propagating messages then there is no problem to the original sender).
\item The Consensus time was set at 3 minutes and not less since that was the expected time for stability being observed in Stage B and C iterations
\item Also the reason for using ordered list data structure was that in this case the vehicle numbers would be sorted in ascending order so in the best case scenario first \(n\) vehicles would be killed which are all in different axis. Another reason for making a sorted list is to make the operation of finding of vehicle faster through binary search (although I used a linear search due to time constraints in Assignment).
\item A very important fact in building my lookup table was that it should be static. Because of that I made it with respect to the \texttt{Target\_No\_Of\_Vehicles} and not on the Total\(_{\text{Number}}\)\(_{\text{Of}}\)\(_{\text{Vehicles}}\) or any other sort of Dynamically created instance of the project (like the \texttt{Initial\_No\_Of\_Elements})
\item For killing of the vehicle, I made it go a little further from it's position and stay stuck there until it dies. If I tried to send a lot of vehicles in different directions, the
\item The results of Stage D indicate that the number of vehicles after consensus time is not exactly equal to the remaining elements. There seemed to be an error of \(\pm (0-6)\) vehicles when \texttt{Target\_No\_Elements} is high. The difference was propounded when we take \texttt{Target\_No\_Of\_Elements} as low.
\item There was an extreme case for 500 vehicles and 42 \texttt{Target\_No\_Of\_Elements}. In that, I seemed to get the error message
\begin{verbatim}
Warning: Vehicle task termination request ignored - attempting task abort now
Error: Vehicle task stuck in non-abortable code region - task abort failed
Warning: Vehicle task termination request ignored - attempting task abort now
Error: Vehicle task stuck in non-abortable code region - task abort failed
Warning: Vehicle task termination request ignored - attempting task abort now
\end{verbatim}
\item This means that the either the lookup table is not being constructed properly (which is the case) and also consensus is not being reached in the stipulated time.
\end{itemize}
\section{Testing and Results Tables}
\label{sec:org3fda4a3}
Following conventions are used:
\begin{enumerate}
\item VC - Initial Vehicle Count
\item D - Duration (In Minutes)
\item TV - Target Vehicle Count
\item Ix - Iteration x
\end{enumerate}

Note that the tests are the average of three simulations: \\

\begin{minipage}{0.5\textwidth}
\captionof{table}{Single Globe In Orbit}
\begin{center}
\begin{tabular}{rrrr}
\hline
\textbf{VC / D} & 1 & 5 & 20\\
\hline
64 & 64 & 64 & 64\\
150 & 150 & 150 & 150\\
200 & 200 & 200 & 200\\
300 & 300 & 271 & 271\\
400 & 320 & 317 & 316\\
500 & 340 & 331 & 328\\
\hline
\end{tabular}

\end{center}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\captionof{table}{Dual Globes In Orbits}
\begin{center}
\begin{tabular}{rrrr}
\hline
\textbf{VC / D} & 1 & 5 & 20\\
\hline
64 & 64 & 64 & 64\\
150 & 150 & 150 & 150\\
200 & 199 & 199 & 199\\
300 & 297 & 297 & 297\\
400 & 369 & 369 & 369\\
500 & 434 & 428 & 428\\
\hline
\end{tabular}

\end{center}
\end{minipage}

\vspace{2em}

\begin{minipage}{0.5\textwidth}
\captionof{table}{Random Globes In Orbits}
\begin{center}
\begin{tabular}{rrrr}
\hline
\textbf{VC / D} & 1 & 5 & 20\\
\hline
64 & 64 & 64 & 60\\
150 & 150 & 150 & 135\\
200 & 200 & 199 & 171\\
300 & 300 & 290 & 252\\
400 & 399 & 380 & 343\\
500 & 499 & 461 & 413\\
\hline
\end{tabular}

\end{center}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\captionof{table}{Stage D Iterations}
\begin{center}
\begin{tabular}{rrrrr}
\hline
VC & TV & I1 & I2 & I3\\
\hline
100 & 42 & 33 & 38 & 44\\
100 & 64 & 55 & 60 & 70\\
200 & 130 & 133 & 126 & 140\\
200 & 100 & 91 & 101 & 98\\
500 & 42 & 0 & 0 & 0\\
\hline
\end{tabular}

\end{center}
\end{minipage}
\subsubsection*{FPS Performance}
\label{sec:org299e734}
Note that \texttt{XSpecific\_build\_modes} has been set to Performance. The configuration is as follows
\begin{itemize}
\item CPU : Intel® Core™ i7-8750H Processor (9M Cache, up to 4.10 GHz)
\item GPU : NVIDIA GeForce GTX 1050 Ti
\item RAM : 16 GB
\end{itemize}
\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{FPS}
\caption{Performance with respect to number of vehicles}
\end{figure}
\begin{itemize}
\item The framerate goes low as the number of vehicles increase since we are creating a simutation where each vehicle's destination is being calculated at once. So there's a direct correlation between number of vehicles and the FPS slowing down. But this does not correlate with real life simulation since each vehicle will have their own individual simulator.
\item After the death signal is called after the \texttt{Consensus\_Time\_Interval}, the frame rate drops by half in Performance mode whereas it drops by a huge factor (by 5-6x) in Development mode.
\end{itemize}
\section{Conclusion}
\label{sec:orgae5b072}
A scalable design has mostly been implemented for stage B and C. However with respect to Stage D, it seems like it's not been implemented for having the exact \texttt{Target\_No\_Of\_Vehicles}. A major driving force for that is that the lookup table is not common for all. This may be due to a bug in implementation or a case in the algorithm that I missed. However the core principles of the implemented algorithm remain the same. Since the four axis set of vehicles come close to each other, the lookup table should be common for all in the stipulated time. The best approach for a solution would be during the checking time, check that all the lookup tables are equal and none of the vehicles in the lookup table have died in the process. This in my view is the future scope for the project. \\

In the end, I learnt a lot in the process about concepts of message passing and my favorite part was discovering about propagating of message. I also gained some insight in the field of swarm intelligence and I plan to continue on this project with some guidance.

\section{Important points before running the code}
\label{sec:orgf6c05ef}
\begin{itemize}
\item Set \texttt{XSpecific\_build\_modes= Performance}
\item For implementing stage B and C comment out the part of the code where bootstrapping of \texttt{Type\_Y} message is present.
\item Toggling on Neighbourhood lines while vehicles are dying gives a run-time error [5].
\item For very low amount of vehicles, one may need to adjust the dials given in the source code.
\end{itemize}
\section{References}
\label{sec:org29603ef}
[1] Uwe R. Zimmer, S2 2020, Concurrent and Distributed Systems, Assignment 1, Australian National University, \url{https://cs.anu.edu.au/courses/comp2310/1-Labs-Assignments.html}, referred on September 15 2020

[2] Piazza Forums, Concurrent and Distributed Systems, \url{https://piazza.com/class/kcx5gab0r6o1d?cid=485}, referred on September 15 2020

[3] Three-Dimensional Rotation Matrices, \url{http://scipp.ucsc.edu/\~haber/ph216/rotation\_12.pdf}

[4] Uwe R. Zimmer, S2 2020, Concurrent and Distributed Systems, Week 5: Pipelined Insertsort, Australian National University, delivered 24 August 2020.

[5] Piazza Forums, Concurrent and Distributed Systems, \url{https://piazza.com/class/kcx5gab0r6o1d?cid=627}, referred on September 29 2020

[6] Other sources include Microsoft Teams Chat and Posts on Piazza (where students discussed some ideas like generic packages, various approaches, etc)
\end{document}